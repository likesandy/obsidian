## 哈希函数
# 哈希表

## 介绍

哈希表：通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询

在哈希表中，我们将数组中的每个空位称为`桶bucket`,每个桶可存储一个键值对
因此，查询操作就是找到 `key` 对应的桶，并在桶中获取 `value` 

那么，如何基于 `key` 来定位对应的桶呢？这是通过`哈希函数`实现的

哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间

**我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置**

输入一个 `key` ，哈希函数的计算过程分为以下两步
- 通过某种哈希算法得到哈希值
- 将哈希值对桶数量（数组长度）`capacity` 取模，从而获取该 `key` 对应的数组索引 `index` 

为什么是取模？而不是其他的压缩方法？

后面哈希算法的时候会说~

## 哈希冲突

本质上看，哈希函数的作用是将所有 `key` 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间

因此，理论上一定存在**多个输入对应相同输出**的情况
例如，查询学号为 12836 和 20336 的两个学生时，我们得到：

```js
12836 % 100 = 36
20336 % 100 = 36
```

两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为**哈希冲突 `hash collision`**

哈希表容量越大，多个 `key` 被分配到同一个桶中的概率就越低，冲突就越少

因此，我们可以通过**扩容哈希表**来减少哈希冲突

> 生活案例：我准备了一桌子菜（容量），但是来了两桌客人（输入），这饭怎么吃？两桌人挤在一桌子吃？（冲突）只能再去准备一桌子菜（扩容）

**负载因子** `load factor`定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度

例如在 `Java` 中，当负载因子超过`0.75`时，系统会将哈希表容量扩展为原先的 `2` 倍 

哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时

并且由于哈希表容量 `capacity` 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置

为了提升效率，我们可以采用以下策略
- 链式地址
- 开放寻址

### 链式地址

哈希表结构：数组->链表

值得注意的是，当链表很长时，查询效率`O(n)`很差。此时可以将链表转换为**AVL 树**或**红黑树**，从而将查询操作的时间复杂度优化至`O(logn)`

### 开放寻址

开放地址法的主要工作方式是**寻找空白的单元格来添加重复的数据**

#### 线性探测

线性探测采用固定步长的线性搜索来进行探测

插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历，直至找到空桶，将元素插入其中

查找元素：如果发现哈希冲突，则从冲突位置往后线性遍历，直至找到目标元素；如果遇到空位，则说明元素不在哈希表中，返回`Null`

删除元素：删除元素时，我们需要找到该元素在哈希表中的位置，但是不能直接删除元素，而是通过**懒删除机制**，利用一个常量`TOMBSTONE`（墓碑，删除标记）来标记这个桶，`TOMBSTONE`和`None`都代表空桶，在可以进行插入元素，但是不同的是，在线性探索的时候遇到-1可以继续往后遍历

然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 `TOMBSTONE` 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 `TOMBSTONE` 才能找到目标元素

为此，可以考虑在线性探测中记录遇到的首个 `TOMBSTONE` 的索引，并将搜索到的目标元素与该 `TOMBSTONE` 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离探测起始点更近的桶，从而优化查询效率

线性探测容易产生**聚集现象**。具体来说，数组中连续被占用的位置越长，向后线性遍历的次数就越多，增删改查的性能都会受损


#### 平方探测

平方探测主要优化的是探测时的步长

平方探测通过跳过平方的距离，试图缓解线性探测的聚集效应

平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀

然而平方探测仍然存在聚集现象，元素会聚集在特定的位置


#### 多次哈希

多次哈希使用多个哈希函数$f(x)_1,f(x)_2,...,f(x)_k$进行探测
- 插入元素：若哈希函数$f(x)_1$ 出现冲突，则尝试$f(x)_2$ ，以此类推，直到找到空桶后插入元素
- 查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；或当遇到空桶或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回$None$
 
多次哈希可以提高哈希表的性能，但需要选择合适的哈希函数，并且计算成本较高

## 哈希函数

质数：前人大量的计算，大量的观察

质数和其他数相乘的结果相比于其他数字更容易产生唯一性的结果，减少哈希冲突

让我们得到的索引在数组中分配得更加均匀