## 类组件生命周期介绍
React 两个重要阶段，`render` 阶段和 `commit` 阶段
React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点

如果在一次调和的过程中，发现了一个 `fiber tag = 1` 类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过
`react-reconciler/src/ReactFiberBeginWork.js`
```jsx
function updateClassComponent(
  current: Fiber | null, // 当前 Fiber 节点
  workInProgress: Fiber, // 正在进行调和的 Fiber树
  Component: any, // class 组件
  nextProps: any, // 更新后的props
  renderLanes: Lanes // 渲染优先级
) {
  // 当前实例
  const instance = workInProgress.stateNode // stateNode可以访问fiber指向的实例
  // 是否需要更新
  let shouldUpdate
  // 如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程
  if (instance === null) {
    // 创建实例
    constructClassInstance(workInProgress, Component, nextProps)
    // 挂载实例
    mountClassInstance(workInProgress, Component, nextProps, renderLanes)
    // 需要更新
    shouldUpdate = true
  } else {
    // 更新组件流程
    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes)
  }
  if (shouldUpdate) {
    // 执行render函数 ，得到子节点
    nextChildren = instance.render()
    // 继续调和子节点
    reconcileChildren(current, workInProgress, nextChildren, renderLanes)
  }
}
```
![[Pasted image 20231204230226.png]]
## React 类组件生命周期执行过程
React 的大部分生命周期的执行，都在 `mountClassInstance` 和`updateClassInstance` 这两个方法中执行
为了方便理解，分为**组件初始化**，**组件更新** ， **组件销毁** ，三大阶段分析
### 初始化阶段
**①constructor 执行**
在 mount 阶段，首先执行的 `constructClassInstance` 函数，用来实例化 React 组件
`react-reconciler/src/ReactFiberClassComponent.js`
```jsx
function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
  const instance = workInProgress.stateNode
  // 获取类组件的getDerivedStateFromProps hook
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps

  if (typeof getDerivedStateFromProps === 'function') {
    // 执行 getDerivedStateFromProps Hooks得到将合并的state
    const partialState = getDerivedStateFromProps(nextProps, prevState)
    // 合并state
    const memoizedState =
      partialState === null || partialState === undefined
        ? prevState
        : Object.assign({}, prevState, partialState)
    workInProgress.memoizedState = memoizedState
    // 将state 赋值到实例上，instance.state  就是我们在组件中 this.state获取的state
    instance.state = memoizedState
  }

  // 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount
  if (
    typeof ctor.getDerivedStateFromProps !== 'function' &&
    typeof instance.getSnapshotBeforeUpdate !== 'function' &&
    typeof instance.componentWillMount === 'function'
  ) {
    instance.componentWillMount()
  }
}
```
**②getDerivedStateFromProps 执行**
**③componentWillMount 执行**
如果存在 `getDerivedStateFromProps` 和 `getSnapshotBeforeUpdate` 就不会执行生命周期`componentWillMount`
**④render 函数执行**
在执行完 `mountClassInstancec` 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children
**⑤componentDidMount执行**
一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 `componentDidMount` 生命周期
`react-reconciler/src/ReactFiberCommitWork.js`
```jsx
function commitLifeCycles(finishedRoot, current, finishedWork) {
  // 类实例
  const instance = finishedWork.stateNode
  /* 类组件第一次调和渲染 */
  if (current === null) {
    instance.componentDidMount()
  } else {
  /* 类组件更新 */
    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate)
  }
}
```
从上面可以直观看到 `componentDidMount` 执行时机 和 `componentDidUpdate` 执行时机是相同的 ，只不过一个是针对初始化，一个是针对组件再更新。到此初始化阶段，生命周期执行完毕
![[Pasted image 20231204233151.png]]
### 更新阶段
回到了最开始 `updateClassComponent` 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理
`react-reconciler/src/ReactFiberClassComponent.js`
```jsx
function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
  // 类组件实例
  const instance = workInProgress.stateNode

  // 判断是否存在getDerivedStateFromProps
  const hasNewLifecycles = typeof ctor.getDerivedStateFromProps === 'function'

  // 如果getDerivedStateFromProps不存在, 并且props或者context发生变化, 则执行componentWillReceiveProps
  if (!hasNewLifecycles && typeof instance.componentWillReceiveProps === 'function') {
    if (oldProps !== newProps || oldContext !== nextContext) {
      // 浅比较 props 不相等
      instance.componentWillReceiveProps(newProps, nextContext)
    }
  }

  // 如果getDerivedStateFromProps存在, 返回的值用于合并state，生成新的state
  let newState = (instance.state = oldState)
  if (typeof getDerivedStateFromProps === 'function') {
    ctor.getDerivedStateFromProps(nextProps, prevState)
    newState = workInProgress.memoizedState
  }

  // 需要更新
  let shouldUpdate = true
  // 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点
  if (typeof instance.shouldComponentUpdate === 'function') {
    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext)
  }
  // 执行componentWillUpdate
  if (shouldUpdate) {
    if (typeof instance.componentWillUpdate === 'function') {
      instance.componentWillUpdate()
    }
  }
  return shouldUpdate
}
```
接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点
执行`getSnapshotBeforeUpdate`，返回值将作为参数传递给 `componentDidUpdate`
执行`componentDidUpdate`，此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕
![[Pasted image 20231205001005.png]]



## 函数组件生命周期替代方案
### useEffect
