选择排序的工作原理很简单，**开启一个循环，每次在未排序区间里选择最小的元素，将其放在已排序区间的末尾**
![[Pasted image 20231117231315.png]]
选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换
在已经执行了n-1轮循环后，剩下的最后一个元素自然就是最大的元素，无需再次比较和交换位置
```typescript
const nums = [72, 50, 10, 44, 8, 20]
console.log('排序前', nums) // [72, 50, 10, 44, 8, 20]
selectionSort(nums)
console.log('排序后', nums) // [8, 10, 20, 44, 50, 72]

function selectionSort(byun: number[]): number[] {
  const n = arr.length
  //  外循环：未排序区间[0,n-1]
  for (let i = 0; i < n - 1; i++) {
    // 内循环：找到未排序部分中最小值的下标
    let k = i
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[k]) k = j
    }

    // 将该最小元素与未排序区间的首个元素交换
    if (i !== k) [arr[i], arr[k]] = [arr[k], arr[i]]
  }
  return arr
}
```
时间复杂度为$O(n^2)$,非自适应排序
空间复杂度 $O(1)$、原地排序
**非稳定排序**：元素 `nums[i]` 有可能被交换至与其相等的元素的右边，导致两者相对顺序发生改变
