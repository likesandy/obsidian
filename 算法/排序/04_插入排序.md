选择排序不稳定，无法应用于多级排序插入排序的工作原理与手动整理一副牌的过程非常相似
我们在未排序区间选择一个**基准元素**，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置
## 算法流程
1. 初始状态下，数组的第 1 个元素已完成排序
2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，数组的前 2 个元素已排序
3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，数组的前 3 个元素已排序
4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，所有元素均已排序
![[Pasted image 20231118152450.png]]
```typescript
const nums = [72, 50, 10, 44, 8, 20]
console.log('排序前', nums) // [72, 50, 10, 44, 8, 20]
insertionSort(nums)
console.log('排序后', nums) // [8, 10, 20, 44, 50, 72]

function insertionSort(nums: number[]): void {
  const n = nums.length
  for (let i = 1; i < n; i++) {
    const base = nums[i]
    let j = i - 1
    while (j >= 0 && nums[j] > base) {
      nums[j + 1] = nums[j]
      j--
    }
    nums[j + 1] = base
  }
}
```
时间复杂度为$O(n^2)$、自适应排序：每次插入操作分别需要循环 $n−1、n−2、.... 、1 次，求和得到 (n−1)n/2$ ，因此时间复杂度为 $O(n^2)$，当输入数组完全有序时，插入排序达到最佳时间复杂度$O(n)$
空间复杂度为$O(1)$、原地排序
稳定排序
## 优势
插入排序的时间复杂度为 $O(n^2)$ ，而我们即将学习的快速排序的时间复杂度为 $O(nlogn)$ 。尽管插入排序的时间复杂度相比快速排序更高，但在数据量较小的情况下，插入排序通常更快
在数据量较小时，$O(n^2)$和 $O(nlogn)$  的数值比较接近，复杂度不占主导作用；每轮中的单元操作数量起到决定性因素
实际上，许多编程语言（例如 Java）的内置排序函数都采用了插入排序，大致思路为：对于长数组，采用基于分治的排序算法，例如快速排序；对于短数组，直接使用插入排序
虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $O(n^2)$ ，但在实际情况中，**插入排序的使用频率显著高于冒泡排序和选择排序**，主要有以下原因
- 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，**冒泡排序的计算开销通常比插入排序更高**
- 选择排序在任何情况下的时间复杂度都为 $O(n^2)$ 。**如果给定一组部分有序的数据，插入排序通常比选择排序效率更高**
- 选择排序是**非稳定排序**
